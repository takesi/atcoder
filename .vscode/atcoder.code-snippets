{
  "template": {
    "prefix": "temp",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#ifdef LOCAL",
      "#include \"../lib/dump.hpp\"",
      "#else",
      "#define dump(...)",
      "#define dumpv(...)",
      "#endif",
      "",
      "typedef long long ll;",
      "typedef pair<int, int> P;",
      "const int MOD = 1e9 + 7;",
      "const int INF = 1001001001;",
      "const ll LINF = 1001002003004005006ll;",
      "",
      "int main()",
      "{",
      "  cin.tie(0);",
      "  ios::sync_with_stdio(false);",
      "  // freopen(\"temp.1\", \"r\", stdin);",
      "",
      "  $1",
      "  return 0;",
      "}"
    ],
    "description": "template"
  },
  "for loop": {
    "prefix": "for",
    "body": [
      "for (int ${1:i} = 0; $1 < ${2:N}; $1++) {",
      "  $3",
      "}"
    ],
    "description": "for loop"
  },
  "for loop reverse": {
    "prefix": "forr",
    "body": [
      "for (int ${1:i} = ${2:N} - 1; 0 <= $1; $1--) {",
      "  $3",
      "}"
    ],
    "description": "for loop reverse"
  },
  "mins & maxs": {
    "prefix": "minmax",
    "body": [
      "#define mins(x, y) (x = min(x, y))",
      "#define maxs(x, y) (x = max(x, y))"
    ],
    "description": "mins & maxs"
  },
  "tuple": {
    "prefix": "tuple",
    "body": [
      "// usage:",
      "// vector<T> v; v.push_back(T(1, 2, 3)); v.emplace_back(1, 2, 3);",
      "// queue<T> q; q.push(T(1, 2, 3));",
      "// int x, y, z; tie(x, y, z) = q.front(); q.pop();",
      "typedef tuple<int, int, int> T;"
    ],
    "description": "tuple template"
  },
  "struct": {
    "prefix": "struct",
    "body": [
      "// usage:",
      "// vector<S> v; v.push_back(S(1, 2, \"abc\")); v.emplace_back(1, 2, \"abc\");",
      "// S& s = v[0];",
      "struct S",
      "{",
      "  int x, y;",
      "  string s;",
      "  S(int x = 0, int y = 0, string s = \"#\") : x(x), y(y), s(s) {}",
      "};",
      "inline ostream& operator<<(ostream& o, const S& v) { return o << v.x << \",\" << v.y << \",\" << v.s; }"
    ],
    "description": "struct template"
  },
  "gcd": {
    "prefix": "gcd",
    "body": [
      "ll gcd(ll a, ll b) { return (a == 0) ? b : gcd(b % a, a); }"
    ],
    "description": "最大公約数"
  },
  "lcm": {
    "prefix": "lcm",
    "body": [
      "ll gcd(ll a, ll b) { return (a == 0) ? b : gcd(b % a, a); }",
      "ll lcm(ll a, ll b) { return (a * b) / gcd(a, b); }"
    ],
    "description": "最小公倍数"
  },
  "tree-init": {
    "prefix": "tree",
    "body": [
      "vector<vector<int>> to(N);",
      "for (int i = 0; i < N - 1; i++) {",
      "  int u, v;",
      "  cin >> u >> v;",
      "  u--, v--;",
      "  to[u].push_back(v);",
      "  to[v].push_back(u);",
      "}"
    ],
    "description": "treeの初期化"
  },
  "bfs-tree": {
    "prefix": "bfs",
    "body": [
      "queue<int> q;",
      "vector<int> used(N);",
      "q.push(0);",
      "while (!q.empty()) {",
      "  int v = q.front();",
      "  q.pop();",
      "  if (used[v])",
      "    continue;",
      "  used[v] = 1;",
      "  for (auto& u : to[v]) {",
      "    q.push(u);",
      "  }",
      "}"
    ],
    "description": "bfsでto[]の木探索"
  },
  "dfs-tree": {
    "prefix": "dfs",
    "body": [
      "vector<int> used(N);",
      "function<void(int, int)> dfs = [&](int v, int from) {",
      "  if (used[v])",
      "    return;",
      "  used[v] = 1;",
      "  for (auto& u : to[v]) {",
      "    dfs(u, v);",
      "  }",
      "};",
      "dfs(0, -1);"
    ],
    "description": "dfsでto[]の木探索"
  },
  "mint": {
    "prefix": "mint",
    "body": [
      "struct mint",
      "{",
      "  ll v;",
      "  mint() : v(0) {}",
      "  mint(ll v) : v((v % MOD + MOD) % MOD) {}",
      "};",
      "mint& operator+=(mint& a, mint b) { return a = a.v + b.v; }",
      "mint& operator-=(mint& a, mint b) { return a = a.v - b.v; }",
      "mint& operator*=(mint& a, mint b) { return a = a.v * b.v; }",
      "mint operator+(mint a, mint b) { return a += b; }",
      "mint operator-(mint a, mint b) { return a -= b; }",
      "mint operator*(mint a, mint b) { return a *= b; }",
      "mint operator-(mint a) { return 0 - a; }"
    ],
    "description": "mint (最低限の実装)"
  },
  "nvec": {
    "prefix": "nvec",
    "body": [
      "struct nvec : public vector<int>",
      "{",
      "  int base;",
      "  nvec(int len, int base) : vector<int>(len), base(base) {}",
      "  nvec& operator++()",
      "  {",
      "    for (int i = 0; i < size(); i++) {",
      "      at(i)++;",
      "      if (at(i) < base)",
      "        break;",
      "      at(i) = 0;",
      "    }",
      "    return *this;",
      "  };",
      "  nvec& operator++(int dummy) { return operator++(); };",
      "};"
    ],
    "description": "n進数vector (最低限の実装)"
  },
  "yakubun": {
    "prefix": "yakubun",
    "body": [
      "vector<int> x;",
      "int num = n;",
      "for (int i = 1; i * i <= n; i++) {",
      "  if (num % i == 0) {",
      "    x.push_back(i);",
      "    if (i != 1 && i * i != n) {",
      "      x.push_back(n / i);",
      "    }",
      "  }",
      "}"
    ],
    "description": "約数の列挙"
  },
}